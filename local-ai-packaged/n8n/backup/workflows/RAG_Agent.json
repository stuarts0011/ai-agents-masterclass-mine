{
  "name": "RAG Agent",
  "nodes": [
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "29a3a427-9c50-4f80-b220-cdb198218070",
      "name": "Aggregate1",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        -600,
        200
      ]
    },
    {
      "parameters": {
        "fieldsToSummarize": {
          "values": [
            {
              "aggregation": "concatenate",
              "field": "data"
            }
          ]
        },
        "options": {}
      },
      "id": "67393c56-fe6e-4346-866f-4fdabbf4de2c",
      "name": "Summarize1",
      "type": "n8n-nodes-base.summarize",
      "typeVersion": 1,
      "position": [
        -440,
        200
      ]
    },
    {
      "parameters": {
        "operation": "pdf",
        "binaryPropertyName": "=data",
        "options": {}
      },
      "id": "92f37118-4ae2-4a29-8598-0eb9e50a0313",
      "name": "Extract PDF Text",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -800,
        40
      ]
    },
    {
      "parameters": {
        "operation": "xlsx",
        "binaryPropertyName": "=data",
        "options": {}
      },
      "id": "a7f25de8-ac43-432c-919d-bb8dfffb03ac",
      "name": "Extract from Excel",
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -800,
        200
      ]
    },
    {
      "parameters": {
        "chunkSize": 2000,
        "chunkOverlap": 200,
        "options": {
          "splitCode": "markdown"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        140,
        700
      ],
      "id": "796d8bdc-e131-4522-b3a9-2f8f53ab1205",
      "name": "Recursive Character Text Splitter"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Read File1').item.json.mimeType }}",
                    "rightValue": "application/pdf",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "pdf"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "2ae7faa7-a936-4621-a680-60c512163034",
                    "leftValue": "={{ $('Read File1').item.json.mimeType }}",
                    "rightValue": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "excel"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "7ddfa924-1c26-4ee3-9890-5c9d2b96717a",
                    "leftValue": "={{ $('Read File1').item.json.mimeType }}",
                    "rightValue": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "docx"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "f53caf8b-7a8f-4d1e-98f4-deaf0e0171f0",
                    "leftValue": "={{ $('Read File1').item.json.mimeType }}",
                    "rightValue": "application/msword",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "docm"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "cd9ca627-d00d-4c30-903a-41f603c8e36f",
                    "leftValue": "={{ $('Read File1').item.json.mimeType }}",
                    "rightValue": "application/vnd.ms-word",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "ms-word"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "dfe08094-6bc1-41ee-adcf-5af5d287b5bf",
                    "leftValue": "={{ $('Read File1').item.json.mimeType }}",
                    "rightValue": "=application/vnd.ms-outlook",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "msg"
            }
          ]
        },
        "options": {}
      },
      "id": "ef1162ae-a882-4ee4-bdc0-0a4b1aeb8021",
      "name": "Switch2",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        -980,
        260
      ]
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": "rag_vectors",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "2f9bbcb9-d5f6-4a70-9e83-cbbadc1c2282",
      "name": "Postgres PGVector Store2",
      "credentials": {
        "postgres": {
          "id": "9DsnG4z6KNJd9AdE",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "d15cde67-b5b0-4676-b4fb-ead749147392",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $('Process Initial Files').first().json.type === 'file_changed' }}",
                    "rightValue": "changed"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "file_changed"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{$('Process Initial Files').first().json.type === 'file_added'}}",
                    "rightValue": "add"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "file_added"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "6f84bafc-b92a-42e5-9520-99ffca3a21df",
                    "leftValue": "={{$('Process Initial Files').first().json.type === 'file_initial'}}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "file_initial"
            }
          ]
        },
        "options": {}
      },
      "id": "cfa574e7-2fc9-4bc1-8c30-16bd89a3594c",
      "name": "Handle File Event",
      "type": "n8n-nodes-base.switch",
      "position": [
        -1160,
        300
      ],
      "typeVersion": 3,
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "fileSelector": "={{$json.type === 'file_added' || $json.type === 'file_changed' || $json.type === 'file_initial' ? $json.filePath : ''}}",
        "options": {
          "dataPropertyName": "data"
        }
      },
      "id": "29a5cd6a-1c26-434f-a6bc-44dea2d4fdc1",
      "name": "Read File1",
      "type": "n8n-nodes-base.readWriteFile",
      "position": [
        -1900,
        300
      ],
      "typeVersion": 1,
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "jsCode": "const path = require('path');\nconst { Msg, PidTagAttachFilename, PidTagSubject, PidTagTo, PidTagFrom, PidTagBody, PidTagSenderName, PidTagSenderEmailAddress, PidTagDisplayTo, PidTagDisplayFrom, PidTagClientSubmitTime, PidTagReceivedTime, PidTagDateSent, PidTagDisplayCc, PidTagDisplayBcc, PidTagOriginalDisplayCc, PidTagOriginalDisplayBcc } = require('msg-parser');\nconst fs = require('fs');\nconst os = require('os');\nconst mime = require('mime-types');\n\n// Ensure the output folder exists\nconst outputFolder = path.join(os.tmpdir(), \"msg_parser_output\");\nif (!fs.existsSync(outputFolder)) {\n    fs.mkdirSync(outputFolder);\n}\n\n// Get the file path from the input data\nconst filePath = $('Set Identifier').item.json.filePath;  // Adjust as necessary for your setup\n\n// Read the .msg file asynchronously\nconst data = await fs.promises.readFile(filePath);\nconst msg = Msg.fromUint8Array(new Uint8Array(data));\n\nconst result = [];\n\nfunction safeGetProperty(msg, propertyId) {\n    try {\n        return msg.getProperty(propertyId) || '';\n    } catch {\n        return '';\n    }\n}\n\n// Recursive function to process message, attachments, and embedded messages\nasync function processMessage(msg, depth = 0) {\n    const currentResult = [];\n\n    // Process the current message data, including CC and BCC\n    currentResult.push({\n        json: {\n            type: 'msg',\n            to: safeGetProperty(msg, PidTagTo) || safeGetProperty(msg, PidTagDisplayTo),\n            from: safeGetProperty(msg, PidTagFrom) || safeGetProperty(msg, PidTagSenderName) || safeGetProperty(msg, PidTagSenderEmailAddress) || safeGetProperty(msg, PidTagDisplayFrom),\n            cc: safeGetProperty(msg, PidTagDisplayCc) || safeGetProperty(msg, PidTagOriginalDisplayCc),  // Use correct CC properties\n            bcc: safeGetProperty(msg, PidTagDisplayBcc) || safeGetProperty(msg, PidTagOriginalDisplayBcc),  // Use correct BCC properties\n            subject: safeGetProperty(msg, PidTagSubject),\n            date: safeGetProperty(msg, PidTagClientSubmitTime) || safeGetProperty(msg, PidTagReceivedTime) || safeGetProperty(msg, PidTagDateSent),\n            contents: safeGetProperty(msg, PidTagBody)\n        }\n    });\n\n    // Process attachments for the current message\n    await Promise.all(msg.attachments().map(async (attachment, index) => {\n        const fileName = safeGetProperty(attachment, PidTagAttachFilename) || `attachment_${index + 1}`;\n        const attachmentFilePath = path.join(outputFolder, fileName.replace(/[\\\\/:*?\"<>|]/g, '_'));\n\n        // Write the attachment to file\n        fs.writeFileSync(attachmentFilePath, Buffer.from(attachment.content()));\n\n        // Detect MIME type based on the file extension\n        const mimeType = mime.lookup(attachmentFilePath) || 'application/octet-stream';\n\n        // Pass the binary content as Buffer\n        const binaryData = Buffer.from(attachment.content());\n\n        // Push the attachment data into N8N's expected format\n        currentResult.push({\n            json: {\n                type: 'attachment',\n                fileName,\n                mimeType,\n                filePath: attachmentFilePath,\n            },\n            binary: {\n                data: binaryData,  // Buffer type\n                fileName: fileName  // Include the fileName for N8N to recognize the binary content\n            }\n        });\n    }));\n\n    // Process embedded messages recursively\n    await Promise.all(msg.embeddedMessages().map(async (embeddedMsg, index) => {\n        try {\n            const embeddedMessage = msg.extractEmbeddedMessage(embeddedMsg);\n            const embeddedResults = await processMessage(embeddedMessage, depth + 1);\n\n            // Include the embedded message results in the current result\n            currentResult.push(...embeddedResults);\n        } catch (error) {\n            console.error('Error processing embedded message:', error);\n        }\n    }));\n\n    return currentResult;\n}\n\n// Process the root message and recursively handle embedded messages and attachments\nconst resultItems = await processMessage(msg);\n\n// Return the result as individual items\nreturn resultItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -800,
        580
      ],
      "id": "5542b220-a396-461e-90eb-431ded98827d",
      "name": "Email Msg Parser",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "triggerOn": "folder",
        "path": "/data/clientfiles",
        "events": [
          "add",
          "unlink",
          "change"
        ],
        "options": {
          "ignoreInitial": false,
          "usePolling": true
        }
      },
      "type": "n8n-nodes-base.localFileTrigger",
      "typeVersion": 1,
      "position": [
        -2860,
        300
      ],
      "id": "7de167b5-95c8-4042-a7d5-eebd291777b8",
      "name": "Local File Trigger"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "dfe08094-6bc1-41ee-adcf-5af5d287b5bf",
                    "leftValue": "={{ $json[\"type\"] === \"msg\" }}",
                    "rightValue": "=application/vnd.ms-outlook",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "msg"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "bbcc1789-451a-46d5-be6e-ea7ddbb21071",
                    "leftValue": "={{ $json[\"type\"] === \"attachment\" && $json[\"mimeType\"] === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\"",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "docx"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json[\"type\"] === \"attachment\" && $json[\"mimeType\"] === \"application/pdf\" }}",
                    "rightValue": "application/pdf",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "pdf"
            }
          ]
        },
        "options": {}
      },
      "id": "922c1ae5-0eba-416e-8b06-067760cafbc2",
      "name": "Switch3",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        -600,
        580
      ]
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -220,
        640
      ],
      "id": "fb722f6e-d871-445a-81f7-611647370798",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst os = require('os');\n\n// Get filePath from previous node's output\nconst getFilePath = (item) => {\n  // First try common file path properties\n  if (item.json.filePath) return item.json.filePath;\n  if (item.json.path) return item.json.path;\n  \n  // Fallback to reconstructing from directory/fileName\n  if (item.json.directory && item.json.fileName) {\n    return path.join(item.json.directory, item.json.fileName);\n  }\n\n  throw new Error('No valid file path found in item JSON');\n};\n\nreturn $input.all().map(item => {\n  try {\n    const filePath = getFilePath(item);\n    const stats = fs.statSync(filePath);\n\n    // Windows/Linux compatible owner detection\n    let owner = '';\n    try {\n      if (os.platform() === 'win32') {\n        const execSync = require('child_process').execSync;\n        owner = execSync(`powershell -Command \"(Get-Acl '${filePath}').Owner\"`)\n          .toString().trim();\n      } else {\n        const uid = stats.uid;\n        owner = os.userInfo(uid).username;\n      }\n    } catch (e) {\n      owner = 'unknown';\n    }\n\n    // Generate identifiers\n    const createdIdentifier = crypto\n      .createHash('sha256')\n      .update(`${path.basename(filePath)}-${stats.birthtimeMs}-${owner}`)\n      .digest('hex');\n\n    const modifiedIdentifier = crypto\n      .createHash('sha256')\n      .update(`${path.basename(filePath)}-${stats.mtimeMs}-${owner}`)\n      .digest('hex');\n\n    return {\n      json: {\n        ...item.json,\n        filePath: path.resolve(filePath), // Standardized absolute path\n        fileName: path.basename(filePath),\n        fileSize: stats.size,\n        createdAt: stats.birthtime,\n        modifiedAt: stats.mtime,\n        createdIdentifier,\n        modifiedIdentifier,\n        owner\n      },\n      binary: item.binary\n    };\n  } catch (error) {\n    return {\n      json: {\n        ...item.json,\n        error: `File identification failed: ${error.message}`,\n        stack: error.stack\n      }\n    };\n  }\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1460,
        300
      ],
      "id": "532705d2-e307-48f3-9788-2a931baa3c5d",
      "name": "Set Identifier"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-docx-converter.docxToText",
      "typeVersion": 1,
      "position": [
        -220,
        340
      ],
      "id": "46213722-aa4c-4c07-a510-d8f08a3632cb",
      "name": "DOCX to Text",
      "retryOnFail": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "file_id",
                "value": "={{ $('Set Identifier').item.json.modifiedIdentifier }}"
              },
              {
                "name": "creator",
                "value": "={{ $('Set Identifier').item.json.owner }}"
              },
              {
                "name": "created_at",
                "value": "={{ $('Set Identifier').item.json.createdAt }}"
              },
              {
                "name": "modified_at",
                "value": "={{ $('Set Identifier').item.json.modifiedAt }}"
              },
              {
                "name": "file_name",
                "value": "={{ $('Set Identifier').item.json.fileName }}"
              },
              {
                "name": "file_type",
                "value": "={{$('Read File1').item.json.mimeType.split(\"/\")[1]}} "
              },
              {
                "name": "created_identifier",
                "value": "={{ $('Set Identifier').item.json.createdIdentifier }}"
              },
              {
                "name": "modified_at",
                "value": "={{ $('Set Identifier').item.json.modifiedIdentifier }}"
              },
              {
                "name": "ltl_file_id",
                "value": "={{ $('Set Variables1').item.json.LTL_file_id }}"
              }
            ]
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        100,
        440
      ],
      "id": "0d15ed50-bc1d-482b-9453-546b284fff37",
      "name": "Default Data Loader"
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs');\nconst path = require('path');\n\nfunction getAllFiles(dirPath, arrayOfFiles = []) {\n  const files = fs.readdirSync(dirPath, { withFileTypes: true });\n\n  for (const file of files) {\n    const fullPath = path.join(dirPath, file.name);\n    if (file.isDirectory()) {\n      getAllFiles(fullPath, arrayOfFiles);\n    } else {\n      arrayOfFiles.push(fullPath);\n    }\n  }\n\n  return arrayOfFiles;\n}\n\nconst directoryPath = '/data/clientfiles';\nconst baseDirName = path.basename(directoryPath); // Get \"clientfiles\" as depth 0\nconst allFiles = getAllFiles(directoryPath);\n\nconst output = allFiles.map(filePath => {\n  const stats = fs.statSync(filePath);\n\n  if (!stats.isFile()) {\n    return null;\n  }\n\n  const relativePath = path.relative(directoryPath, filePath);\n  const pathParts = relativePath.split(path.sep);\n  const directories = pathParts.slice(0, -1); // Remove filename\n\n  let LTL_file_id;\n  if (directories.length >= 2) {\n    LTL_file_id = `${directories[0]}${path.sep}${directories[1]}`;\n  } else if (directories.length === 1) {\n    LTL_file_id = directories[0];\n  } else {\n    LTL_file_id = baseDirName; // Use base directory name when no subdirectories\n  }\n\n  return {\n    json: {\n      type: 'file_initial',\n      filePath,\n      fileName: path.basename(filePath),\n      fileSize: stats.size,\n      createdAt: stats.birthtime,\n      modifiedAt: stats.mtime,\n      LTL_file_id\n    }\n  };\n}).filter(item => item !== null);\n\nreturn output;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2520,
        300
      ],
      "id": "78186d40-be29-4e27-9a9c-57bae0c842a7",
      "name": "Set Variables1"
    },
    {
      "parameters": {
        "model": "nomic-embed-text:latest"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOllama",
      "typeVersion": 1,
      "position": [
        0,
        320
      ],
      "id": "edf98051-12f5-4a2a-be98-45939ff26007",
      "name": "Embeddings Ollama1",
      "credentials": {
        "ollamaApi": {
          "id": "xqXac72sGt5IGFOP",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DELETE FROM rag_vectors WHERE metadata->>'createdIdentifier' = '{{ $json[\"createdIdentifier\"] }}';\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -1160,
        560
      ],
      "id": "0c01b1dd-2ddb-4bec-8443-145321c7e930",
      "name": "Delete Original File Records For Changed Files",
      "credentials": {
        "postgres": {
          "id": "9DsnG4z6KNJd9AdE",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "a9d15caa-b022-4686-a27c-a417ee361f82",
              "leftValue": "={{ $json.file_deleted }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -2380,
        300
      ],
      "id": "d90bdc6b-6d9a-4906-a9a3-bea1e1b766d7",
      "name": "If"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DELETE FROM rag_vectors WHERE metadata->>'fileName' = '{{ $json[\"file_deleted\"] }}';\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -2380,
        540
      ],
      "id": "581c6bba-eb52-4062-9fa6-e34d41497aa7",
      "name": "Delete Original File Records For Deleted Files",
      "credentials": {
        "postgres": {
          "id": "9DsnG4z6KNJd9AdE",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Log all items in the input\nconsole.log(\"Inspecting input to Extract node:\");\nconst inputData = $input.all(); // Retrieve all incoming items\n\n// Log each item's structure, including JSON and binary fields\ninputData.forEach((item, index) => {\n    console.log(`Item [${index}]:`);\n    console.log(\"JSON Data:\", item.json); // Log JSON data\n    console.log(\"Binary Data Exists:\", !!item.binary?.data); // Check if binary.data exists\n    if (item.binary?.data) {\n        console.log(\"Binary Data Length:\", item.binary.data.length); // Log binary data length\n        console.log(\"Filename:\", item.json.filename); // Log filename if available\n    } else {\n        console.log(\"Binary Data: Missing\");\n    }\n});\n\nreturn inputData; // Pass the data unchanged to the next node\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -440,
        740
      ],
      "id": "ecd3bea8-4b20-4c89-8050-510b90752a02",
      "name": "Code"
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs');\nconst { pipeline } = require('stream/promises');\nconst { performance } = require('perf_hooks');\n\n// Atomic file processor with resource tracking\nasync function processFileSafely(item) {\n  const startTime = performance.now();\n  const filePath = item.json.filePath;\n  let fd = null;\n  let readStream = null;\n\n  try {\n    // 1. Validate file existence\n    if (!fs.existsSync(filePath)) {\n      console.error(`File not found: ${filePath}`);\n      return {\n        json: {\n          ...item.json,\n          error: 'File not found',\n          processingTime: performance.now() - startTime\n        }\n      };\n    }\n\n    // 2. Open file descriptor\n    fd = await fs.promises.open(filePath, 'r');\n    \n    // 3. Create tracked read stream\n    readStream = fd.createReadStream({\n      autoClose: true,\n      emitClose: true,\n      highWaterMark: 64 * 1024 // 64KB chunks\n    });\n\n    // 4. Create data consumer\n    let bytesProcessed = 0;\n    const consumer = new (require('stream').Writable)({\n      write(chunk, encoding, callback) {\n        bytesProcessed += chunk.length;\n        callback();\n      }\n    });\n\n    // 5. Process with timeout\n    await Promise.race([\n      pipeline(readStream, consumer),\n      new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Timeout after 15s')), 15000)\n      )\n    ]);\n\n    // 6. Get final stats\n    const stats = await fs.promises.stat(filePath);\n\n    return {\n      json: {\n        ...item.json,\n        fileSize: stats.size,\n        bytesProcessed,\n        processingTime: performance.now() - startTime,\n        createdAt: stats.birthtime,\n        modifiedAt: stats.mtime\n      }\n    };\n\n  } catch (error) {\n    console.error(`Error processing ${filePath}:`, error);\n    return {\n      json: {\n        ...item.json,\n        error: error.message,\n        processingTime: performance.now() - startTime\n      }\n    };\n  } finally {\n    // 7. Guaranteed cleanup\n    if (readStream && !readStream.destroyed) {\n      readStream.destroy();\n    }\n    if (fd) {\n      await fd.close();\n    }\n  }\n}\n\n// Sequential processing with progress\nconst results = [];\nconst files = $input.all();\n\nfor (let i = 0; i < files.length; i++) {\n  const item = files[i];\n  console.log(`Processing ${i + 1}/${files.length}: ${item.json.filePath}`);\n  const result = await processFileSafely(item);\n  results.push(result);\n  console.log(`Completed ${i + 1}/${files.length} in ${result.json.processingTime}ms`);\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2060,
        300
      ],
      "id": "15618ea1-ec4e-43f9-a4a2-6232749d4269",
      "name": "Process Initial Files"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-docx-converter.docxToText",
      "typeVersion": 1,
      "position": [
        -220,
        480
      ],
      "id": "b5fffaf8-65d0-4ca6-8a41-8cdd78da7f8b",
      "name": "DOCX to Text1",
      "retryOnFail": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Validate files before processing\nconst MAX_FILE_SIZE = 1024 * 1024 * 1024; // 1GB\nconst ALLOWED_TYPES = ['pdf', 'docx', 'xlsx'];\n\nreturn $input.all().map(item => {\n  if (!ALLOWED_TYPES.some(ext => item.json.filePath.endsWith(ext))) {\n    return { json: { ...item.json, skip: 'Unsupported type' } };\n  }\n  if (item.json.fileSize > MAX_FILE_SIZE) {\n    return { json: { ...item.json, skip: 'File too large' } };\n  }\n  return item;\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2220,
        300
      ],
      "id": "921834ff-a47e-43dd-9d75-2d7c2f8885d1",
      "name": "Preprocessor"
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs'); // Fixes \"fs is not defined\"\n\n// Only skip checkpoint update if Error Handler says so\nif (items[0].json.shouldCheckpoint === false) {\n  return items; // Return items without writing\n}\n\n// Define CHECKPOINT_PATH (adjust path if needed)\nconst CHECKPOINT_PATH = '/data/checkpoints/last_checkpoint.json';\n\n// Define newCheckpoint data (replace with your logic)\nconst newCheckpoint = {\n  lastFile: items[0].json.filePath,\n  timestamp: new Date().toISOString()\n};\n\n// Write checkpoint (synchronous)\nfs.writeFileSync(\n  CHECKPOINT_PATH,\n  JSON.stringify(newCheckpoint, null, 2)\n);\n\n// Return items to continue workflow\nreturn items;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1300,
        300
      ],
      "id": "56d64460-b6e0-48f8-90ff-8a73e5e95a5a",
      "name": "Checkpoint",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs').promises;\nconst path = require('path');\n\n// 1. Check for existing checkpoint\nconst CHECKPOINT_PATH = '/data/checkpoints/last_checkpoint.json';\n\ntry {\n  const checkpoint = JSON.parse(await fs.readFile(CHECKPOINT_PATH, 'utf8'));\n  \n  // 2. Filter already processed files\n  const allFiles = $input.all();\n  const lastFileIndex = allFiles.findIndex(\n    file => file.json.filePath === checkpoint.lastFile\n  );\n  \n  // 3. Return remaining files\n  return allFiles.slice(lastFileIndex + 1);\n\n} catch (error) {\n  // No checkpoint found - start fresh\n  return $input.all();\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2680,
        300
      ],
      "id": "f00eb0d4-7ff5-4a29-9723-23c5730f9cbe",
      "name": "Checkpoint Resume Mechanism"
    },
    {
      "parameters": {
        "jsCode": "// Configure batch size (adjust based on file size)\nconst batchSize = 20; // Files per batch\nconst batches = [];\nlet currentBatch = [];\n\n// Group files into batches\nitems.forEach((item, index) => {\n  currentBatch.push({\n    json: {\n      ...item.json,\n      batchId: Math.floor(index / batchSize) + 1,\n      totalBatches: Math.ceil(items.length / batchSize)\n    },\n    binary: item.binary\n  });\n\n  if(currentBatch.length >= batchSize) {\n    batches.push(currentBatch);\n    currentBatch = [];\n  }\n});\n\n// Add remaining files\nif(currentBatch.length > 0) {\n  batches.push(currentBatch);\n}\n\n// Add 1s delay between batches\nbatches.forEach((batch, index) => {\n  if(index > 0) {\n    batch[0].json._waitUntil = new Date(Date.now() + 1000).toISOString();\n  }\n});\n\nreturn batches.flat();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1740,
        300
      ],
      "id": "020ce70f-9158-4b28-a88c-44f0142415cd",
      "name": "Batch Processor"
    },
    {
      "parameters": {
        "jsCode": "// Inside the Error Handler node\nconst errors = [];\n\nitems.forEach(item => {\n  if (item.json.error) { // Capture explicit errors\n    errors.push({\n      file: item.json.filePath || \"Unknown file\",\n      error: item.json.error,\n      details: item.json.details || \"No additional info\"\n    });\n  }\n});\n\nif (errors.length > 0) {\n  return [{ \n    json: { \n      shouldCheckpoint: false, \n      errors // Now includes specific errors\n    } \n  }];\n} else {\n  return items.map(item => ({\n    json: { ...item.json, shouldCheckpoint: true }\n  }));\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1600,
        300
      ],
      "id": "edf1f6c3-d0a2-41a7-9c2f-4cec5b24a5a0",
      "name": "Error Handler"
    }
  ],
  "pinData": {},
  "connections": {
    "Aggregate1": {
      "main": [
        [
          {
            "node": "Summarize1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize1": {
      "main": [
        [
          {
            "node": "Postgres PGVector Store2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract PDF Text": {
      "main": [
        [
          {
            "node": "Postgres PGVector Store2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from Excel": {
      "main": [
        [
          {
            "node": "Aggregate1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Character Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Switch2": {
      "main": [
        [
          {
            "node": "Extract PDF Text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract from Excel",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "DOCX to Text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "DOCX to Text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "DOCX to Text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Email Msg Parser",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle File Event": {
      "main": [
        [
          {
            "node": "Delete Original File Records For Changed Files",
            "type": "main",
            "index": 0
          },
          {
            "node": "Switch2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read File1": {
      "main": [
        [
          {
            "node": "Batch Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Email Msg Parser": {
      "main": [
        [
          {
            "node": "Switch3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Local File Trigger": {
      "main": [
        [
          {
            "node": "Checkpoint Resume Mechanism",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch3": {
      "main": [
        [
          {
            "node": "Postgres PGVector Store2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "DOCX to Text1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Postgres PGVector Store2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Identifier": {
      "main": [
        [
          {
            "node": "Checkpoint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "Postgres PGVector Store2",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Set Variables1": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Ollama1": {
      "ai_embedding": [
        [
          {
            "node": "Postgres PGVector Store2",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Delete Original File Records For Deleted Files",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Preprocessor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Initial Files": {
      "main": [
        [
          {
            "node": "Read File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preprocessor": {
      "main": [
        [
          {
            "node": "Process Initial Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Checkpoint": {
      "main": [
        [
          {
            "node": "Handle File Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Checkpoint Resume Mechanism": {
      "main": [
        [
          {
            "node": "Set Variables1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Processor": {
      "main": [
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Set Identifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DOCX to Text1": {
      "main": [
        [
          {
            "node": "Postgres PGVector Store2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DOCX to Text": {
      "main": [
        [
          {
            "node": "Postgres PGVector Store2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "ad608b4a-a088-4243-a0e8-8760ddf312f7",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "9968302481397c4ce1b699d8dba188ad1525522743f87030837227e8e5f3fcc0"
  },
  "id": "RAAtTittZ70sovZf",
  "tags": []
}